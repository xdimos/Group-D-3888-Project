mtry = floor(n_features / 3),
respect.unordered.factors = "order",
seed = 123
)
# gets the OOB error
#prediction_error <- test_run$prediction.error
#prediction_error
hyper_grid <- expand.grid(
mtry = floor(n_features * c(.05, .15, .25, .333, .4)),
min.node.size = c(1, 3, 5),
replace = c(TRUE, FALSE),
sample.fraction = c(.5, .63, .8),
error = NA
)
for (i in seq_len(nrow(hyper_grid))) {
fit <- ranger(
formula = met_veg ~ .,
data = train1.1,
num.trees = n_features * 5,
mtry = hyper_grid$mtry[i],
min.node.size = hyper_grid$min.node.size[i],
replace = hyper_grid$replace[i],
sample.fraction = hyper_grid$sample.fraction[i],
verbose = FALSE,
seed = 123,
respect.unordered.factors = 'order',
)
# export OOB error
hyper_grid$error[i] <- fit$prediction.error
}
hyper_grid %>%
arrange(error) %>%
head(10)
rf_impurity <- ranger(
formula = met_veg ~.,
data = train1.1,
num.trees = 2000,
mtry = 1,
min.node.size = 1,
sample.fraction = .50,
replace = FALSE,
importance = "impurity",
respect.unordered.factors = "order",
verbose = FALSE,
seed = 123
)
rf_permute <- ranger(
formula = met_veg ~.,
data = train1.1,
num.trees = 2000,
mtry = 1,
min.node.size = 1,
sample.fraction = .50,
replace = FALSE,
importance = "permutation",
respect.unordered.factors = "order",
verbose = FALSE,
seed = 123
)
veg_top3_imp = sort(rf_impurity$variable.importance,decreasing = TRUE)[1:3]
veg_top3_per = sort(rf_permute$variable.importance,decreasing = TRUE)[1:3]
p1 <- vip::vip(rf_impurity, num_features = 10, bar = FALSE) + theme_bw()
p2 <- vip::vip(rf_permute, num_features = 10, bar = FALSE) +theme_bw()
gridExtra::grid.arrange(p1, p2, nrow = 1)
train1.2 <- train1 %>%
select(-c(met_veg, met_grain, met_meat, met_dairy, met_disc))
test1.2 <- test1 %>%
select(-c(met_veg, met_grain, met_meat, met_dairy, met_disc))
train1.2$met_fruit <- factor(train1.2$met_fruit)
test1.2$met_fruit <- factor(test1.2$met_fruit)
n_features <- length(setdiff(names(data), "met_fruit"))
test_run <- ranger(
met_fruit ~.,
data = train1.2,
mtry = floor(n_features / 3),
respect.unordered.factors = "order",
seed = 123
)
# gets the OOB error
#prediction_error <- test_run$prediction.error
#prediction_error
hyper_grid <- expand.grid(
mtry = floor(n_features * c(.05, .15, .25, .333, .4)),
min.node.size = c(1, 3, 5),
replace = c(TRUE, FALSE),
sample.fraction = c(.5, .63, .8),
error = NA
)
for (i in seq_len(nrow(hyper_grid))) {
fit <- ranger(
formula = met_fruit ~ ., data = train1.2, num.trees = n_features * 5, mtry = hyper_grid$mtry[i],
min.node.size = hyper_grid$min.node.size[i], replace = hyper_grid$replace[i], sample.fraction = hyper_grid$sample.fraction[i],
verbose = FALSE, seed = 123, respect.unordered.factors = 'order',
)
# export OOB error
hyper_grid$error[i] <- fit$prediction.error
}
hyper_grid %>%
arrange(error) %>%
head(10)
rf_impurity2 <- ranger(
formula = met_fruit ~.,
data = train1.2,
num.trees = 2000,
mtry = 1,
min.node.size = 1,
sample.fraction = .50,
replace = FALSE,
importance = "impurity",
respect.unordered.factors = "order",
verbose = FALSE,
seed = 123
)
rf_permute2 <- ranger(
formula = met_fruit ~.,
data = train1.2,
num.trees = 2000,
mtry = 1,
min.node.size = 1,
sample.fraction = .50,
replace = FALSE,
importance = "permutation",
respect.unordered.factors = "order",
verbose = FALSE,
seed = 123
)
fruit_top3_imp = sort(rf_impurity2$variable.importance,decreasing = TRUE)[1:3]
fruit_top3_per = sort(rf_permute2$variable.importance,decreasing = TRUE)[1:3]
p3 <- vip::vip(rf_impurity2, num_features = 10, bar = FALSE) + theme_bw()
p4 <- vip::vip(rf_permute2, num_features = 10, bar = FALSE) +theme_bw()
gridExtra::grid.arrange(p3, p4, nrow = 1)
train1.3 <- train1 %>%
select(-c(met_veg, met_fruit, met_meat, met_dairy, met_disc))
test1.3 <- test1 %>%
select(-c(met_veg, met_fruit, met_meat, met_dairy, met_disc))
train1.3$met_grain <- factor(train1.3$met_grain)
test1.3$met_grain <- factor(test1.3$met_grain)
head(train1.3)
rf_impurity3 <- ranger(
formula = met_grain ~., data = train1.3,num.trees = 2000, mtry = 1, min.node.size = 1, sample.fraction = .50,
replace = FALSE,
importance = "impurity",
respect.unordered.factors = "order",
verbose = FALSE,
seed = 123
)
rf_permute3 <- ranger(
formula = met_grain ~., data = train1.3, num.trees = 2000, mtry = 1, min.node.size = 1, sample.fraction = .50,replace = FALSE,
importance = "permutation",
respect.unordered.factors = "order",
verbose = FALSE,
seed = 123
)
wgr_top3_imp = sort(rf_impurity3$variable.importance,decreasing = TRUE)[1:3]
wgr_top3_per = sort(rf_permute3$variable.importance,decreasing = TRUE)[1:3]
p5 <- vip::vip(rf_impurity3, num_features = 10, bar = FALSE) + theme_bw()
p6 <- vip::vip(rf_permute3, num_features = 10, bar = FALSE) +theme_bw()
gridExtra::grid.arrange(p5, p6, nrow = 1)
train1.4 <- train1 %>%
select(-c(met_veg, met_fruit, met_grain, met_dairy, met_disc))
test1.4 <- test1 %>%
select(-c(met_veg, met_fruit, met_grain, met_dairy, met_disc))
train1.4$met_meat <- factor(train1.4$met_meat)
test1.4$met_meat <- factor(test1.4$met_meat)
hyper_grid <- expand.grid(
mtry = floor(n_features * c(.05, .15, .25, .333, .4)), min.node.size = c(1, 3, 5),
replace = c(TRUE, FALSE), sample.fraction = c(.5, .63, .8), error = NA
)
for (i in seq_len(nrow(hyper_grid))) {
fit <- ranger(
formula = met_meat ~ ., data = train1.4, num.trees = n_features * 5, mtry = hyper_grid$mtry[i],
min.node.size = hyper_grid$min.node.size[i], replace = hyper_grid$replace[i], sample.fraction = hyper_grid$sample.fraction[i],
verbose = FALSE, seed = 123, respect.unordered.factors = 'order',
)
# export OOB error
hyper_grid$error[i] <- fit$prediction.error
}
hyper_grid %>%
arrange(error) %>%
head(10)
rf_impurity4 <- ranger(
formula = met_meat ~., data = train1.4,num.trees = 2000, mtry = 1, min.node.size = 1, sample.fraction = .50,
replace = FALSE,
importance = "impurity",
respect.unordered.factors = "order",
verbose = FALSE,
seed = 123
)
rf_permute4 <- ranger(
formula = met_meat ~., data = train1.4, num.trees = 2000, mtry = 1, min.node.size = 1, sample.fraction = .50,replace = FALSE,
importance = "permutation",
respect.unordered.factors = "order",
verbose = FALSE,
seed = 123
)
p7 <- vip::vip(rf_impurity4, num_features = 10, bar = FALSE) + theme_bw()
p8 <- vip::vip(rf_permute4, num_features = 10, bar = FALSE) +theme_bw()
gridExtra::grid.arrange(p7, p8, nrow = 1)
meat_top3_imp = sort(rf_impurity4$variable.importance,decreasing = TRUE)[1:3]
meat_top3_per = sort(rf_permute4$variable.importance,decreasing = TRUE)[1:3]
train1.5 <- train1 %>%
select(-c(met_veg, met_fruit, met_grain, met_meat, met_disc))
test1.5 <- test1 %>%
select(-c(met_veg, met_fruit, met_grain, met_meat, met_disc))
train1.5$met_dairy <- factor(train1.5$met_dairy)
test1.5$met_dairy <- factor(test1.5$met_dairy)
hyper_grid <- expand.grid(
mtry = floor(n_features * c(.05, .15, .25, .333, .4)), min.node.size = c(1, 3, 5),
replace = c(TRUE, FALSE), sample.fraction = c(.5, .63, .8), error = NA
)
for (i in seq_len(nrow(hyper_grid))) {
fit <- ranger(
formula = met_dairy ~ ., data = train1.5, num.trees = n_features * 5, mtry = hyper_grid$mtry[i],
min.node.size = hyper_grid$min.node.size[i], replace = hyper_grid$replace[i], sample.fraction = hyper_grid$sample.fraction[i],
verbose = FALSE, seed = 123, respect.unordered.factors = 'order',
)
# export OOB error
hyper_grid$error[i] <- fit$prediction.error
}
hyper_grid %>%
arrange(error) %>%
head(10)
rf_impurity5 <- ranger(
formula = met_dairy ~., data = train1.5, num.trees = 2000, mtry = 1, min.node.size = 1, sample.fraction = .50,
replace = FALSE,
importance = "impurity",
respect.unordered.factors = "order",
verbose = FALSE,
seed = 123
)
rf_permute5 <- ranger(
formula = met_dairy ~., data = train1.5, num.trees = 2000, mtry = 1, min.node.size = 1, sample.fraction = .50,replace = FALSE,
importance = "permutation",
respect.unordered.factors = "order",
verbose = FALSE,
seed = 123
)
p9 <- vip::vip(rf_impurity5, num_features = 10, bar = FALSE) + theme_bw()
p10 <- vip::vip(rf_permute5, num_features = 10, bar = FALSE) +theme_bw()
gridExtra::grid.arrange(p9, p10, nrow = 1)
rf_impurity_f <- ranger(
formula = met_dairy ~., data = train1.5, num.trees = 2000, mtry = 1, min.node.size = 3, sample.fraction = .50,
replace = FALSE,
importance = "impurity",
respect.unordered.factors = "order",
verbose = FALSE,
seed = 123
)
rf_permute_f <- ranger(
formula = met_dairy ~., data = train1.5, num.trees = 2000, mtry = 1, min.node.size = 3, sample.fraction = .50,replace = FALSE,
importance = "permutation",
respect.unordered.factors = "order",
verbose = FALSE,
seed = 123
)
dairy_top3_imp = sort(rf_impurity$variable.importance,decreasing = TRUE)[1:3]
dairy_top3_per = sort(rf_permute$variable.importance,decreasing = TRUE)[1:3]
pred_test_veg <- predict(rf_permute, test1.1) # type='response' is the default - used for classification
confusion_veg = confusionMatrix(table(pred_test_veg$predictions, test1.1$met_veg))
veg_acc = unname(confusion_veg$overall["Accuracy"])
veg_sen=unname(confusion_veg$byClass["Sensitivity"])
veg_spec=unname(confusion_veg$byClass["Specificity"])
pred_test_fruit <- predict(rf_permute2, test1.2) # type='response' is the default - used for classification
confusion_fruit=confusionMatrix(table(pred_test_fruit$predictions, test1.2$met_fruit))
fruit_acc = unname(confusion_fruit$overall["Accuracy"])
fruit_sen=unname(confusion_fruit$byClass["Sensitivity"])
fruit_spec=unname(confusion_fruit$byClass["Specificity"])
pred_test_grain <- predict(rf_permute3, test1.3) # type='response' is the default - used for classification
confusion_grain=confusionMatrix(table(pred_test_grain$predictions, test1.3$met_grain))
wgr_acc = unname(confusion_grain$overall["Accuracy"])
wgr_sen=unname(confusion_grain$byClass["Sensitivity"])
wgr_spec=unname(confusion_grain$byClass["Specificity"])
pred_test_meat <- predict(rf_permute4, test1.4) # type='response' is the default - used for classification
confusion_meat=confusionMatrix(table(pred_test_meat$predictions, test1.4$met_meat))
meat_acc = unname(confusion_meat$overall["Accuracy"])
meat_sen=unname(confusion_meat$byClass["Sensitivity"])
meat_spec=unname(confusion_meat$byClass["Specificity"])
pred_test_dairy <- predict(rf_permute5, test1.5) # type='response' is the default - used for classification
confusion_dairy=confusionMatrix(table(pred_test_dairy$predictions, test1.5$met_dairy))
pred_test_f = predict(rf_permute_f, test1.5)
confusion_dairy_f=confusionMatrix(table(pred_test_dairy$predictions, test1.5$met_dairy))
confusion_dairy_f
#my idea that node size could fix specificity is wrong lol
dairy_acc = unname(confusion_dairy$overall["Accuracy"])
dairy_sen=unname(confusion_dairy$byClass["Sensitivity"])
dairy_spec=unname(confusion_dairy$byClass["Specificity"])
accs = round(c(veg_acc,fruit_acc,meat_acc,dairy_acc,wgr_acc),2)
sens = round(c(veg_sen,fruit_sen,meat_sen,dairy_sen,wgr_sen),2)
specs = round(c(veg_spec,fruit_spec,meat_spec,dairy_spec,wgr_spec),2)
vimp=names(veg_top3_imp[1])
fimp=names(fruit_top3_imp[1])
mimp=names(meat_top3_imp[1])
dimp=names(dairy_top3_imp[1])
wimp=names(wgr_top3_imp[1])
imps = c(vimp,fimp,mimp,dimp,wimp)
vper=names(veg_top3_per[1])
fper=names(fruit_top3_per[1])
mper=names(meat_top3_per[1])
dper=names(dairy_top3_per[1])
wper=names(wgr_top3_per[1])
perms = c(vper,fper,mper,dper,wper)
ADG = c('Vegetables/Legumes','Fruits','Meats/Proteins','Dairy (LF)','Wholegrains')
summary = data.frame(ADG,accs,sens,specs,imps,perms)
library(gt)
imps
perms
imps
summary %>%rename('Accuracy' = accs)%>%rename(Sensitivity = sens)%>%rename(Impurity = imps)%>%rename(Permutation=perms)%>%rename(Specificity=specs)%>%mutate(Impurity = case_when(
Impurity =='BMISC'~'BMI',
Impurity =='ADTOTSE'~'Sitting/Lying (mins)',
Impurity=='AGEC'~'Age'
)) %>%mutate(Permutation = case_when(
Permutation=='EXLWTBC'~'Total Exercise',
Permutation=='EXLWVBC'~'Vigorous Exercise',
Permutation=='SEX'~'Sex',
Permutation=='AGEC'~'Age'
))%>%gt()%>% tab_header(
title = "Classification Random Forest")%>% tab_style(
locations = cells_title(groups = "title"),
style= list(cell_text(weight = "bold", size = 20),cell_fill(color = "grey")))%>%tab_style(
style = list(cell_fill(color = "grey"),cell_text(weight = "bold")),
locations = cells_column_labels())
summary %>%rename('Accuracy' = accs)%>%rename(Sensitivity = sens)%>%rename(Impurity = imps)%>%rename(Permutation=perms)%>%rename(Specificity=specs)%>%mutate(Impurity = case_when(
Impurity =='BMISC'~'BMI',
Impurity =='ADTOTSE'~'Sitting/Lying (mins)',
Impurity=='AGEC'~'Age'
)) %>%mutate(Permutation = case_when(
Permutation=='EXLWTBC'~'Total Exercise',
Permutation=='EXLWVBC'~'Vigorous Exercise',
Permutation=='INCDEC'~'Equivilised Income Decile',
Permutation=='SEX'~'Sex',
Permutation=='AGEC'~'Age'
))%>%gt()%>% tab_header(
title = "Classification Random Forest")%>% tab_style(
locations = cells_title(groups = "title"),
style= list(cell_text(weight = "bold", size = 20),cell_fill(color = "grey")))%>%tab_style(
style = list(cell_fill(color = "grey"),cell_text(weight = "bold")),
locations = cells_column_labels())
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(janitor)
library(GGally)
library(dplyr)
library(tidyr)
library(ranger)
library(ggplot2)
library(readr)
library(rpart.plot) # for visual plots
library(caret)
net_measures = read.csv('network_measures.csv')
head(net_measures)
predictors = net_measures %>%select(Eigenvector.Centrality, Betweenness.Centrality, Closeness.centrality, Degree)
ggpairs(predictors)
data=net_measures%>%clean_names()%>%mutate(essential = ifelse(essential==" True",1,0))
data$essential = factor(data$essential)
head(data)
set.seed(20833)
tr_index = createDataPartition(data$essential)$Resample1
train1 <- data[tr_index, ]
train1$essential <- factor(train1$essential)
test1 <- data[-tr_index, ]
test1$essential <- factor(test1$essential)
head(test1)
# train1.1 and test 1.1
train1.1 <- train1 %>%select(-x_name)
test1.1 <- test1%>%select(-x_name)
n_features <- length(setdiff(names(data), "essential"))
train1.1
lethal_fit <- ranger(
essential~.,
data = train1.1,
mtry = floor(n_features / 3),
respect.unordered.factors = "order",
seed = 123
)
# gets the OOB error
prediction_error <- test1.1$prediction.error
prediction_error
hyper_grid <- expand.grid(
mtry = floor(n_features * c(.05, .15, .25, .333, .4)),
min.node.size = c(1, 3, 5),
replace = c(TRUE, FALSE),
sample.fraction = c(.5, .63, .8),
error = NA
)
for (i in seq_len(nrow(hyper_grid))) {
fit <- ranger(
formula = essential ~ .,
data = train1.1,
num.trees = n_features * 5,
mtry = hyper_grid$mtry[i],
min.node.size = hyper_grid$min.node.size[i],
replace = hyper_grid$replace[i],
sample.fraction = hyper_grid$sample.fraction[i],
verbose = FALSE,
seed = 123,
respect.unordered.factors = 'order',
)
# export OOB error
hyper_grid$error[i] <- fit$prediction.error
}
hyper_grid %>%
arrange(error) %>%
head(10)
rf_impurity <- ranger(
formula = essential ~.,
data = train1.1,
num.trees = 2000,
mtry = 1,
min.node.size = 5,
sample.fraction = .50,
replace = FALSE,
importance = "impurity",
respect.unordered.factors = "order",
verbose = FALSE,
seed = 123
)
rf_permute <- ranger(
formula = essential ~.,
data = train1.1,
num.trees = 2000,
mtry = 1,
min.node.size = 5,
sample.fraction = .50,
replace = FALSE,
importance = "permutation",
respect.unordered.factors = "order",
verbose = FALSE,
seed = 123
)
p1 <- vip::vip(rf_impurity, num_features = 10, bar = FALSE,include_type=TRUE) + theme_bw()
p2 <- vip::vip(rf_permute, num_features = 10, bar = FALSE,include_type=TRUE) + theme_bw()
gridExtra::grid.arrange(p1, p2, nrow = 1)
pred_test <- predict(rf_impurity, test1.1) # type='response' is the default - used for classification
confusionMatrix(table(pred_test$predictions, test1.1$essential))
counts = data %>%group_by(essential)%>%summarise(n=n())
(counts$n)[1]/sum(counts$n)
preds = pred_test$predictions
test1$predicted_lethality = preds
test1=test1%>%mutate(acc=(predicted_lethality==essential))
cm = confusionMatrix(table(pred_test$predictions, test1.1$essential))
draw_confusion_matrix <- function(cm) {
layout(matrix(c(1,1,2)))
par(mar=c(2,2,2,2))
plot(c(100, 345), c(300, 450), type = "n", xlab="", ylab="", xaxt='n', yaxt='n')
title('CONFUSION MATRIX', cex.main=2)
# create the matrix
rect(150, 430, 240, 370, col='#3F97D0')
text(195, 435, 'Non-essential', cex=1.2)
rect(250, 430, 340, 370, col='#F7AD50')
text(295, 435, 'Essential', cex=1.2)
text(125, 370, 'Predicted', cex=1.3, srt=90, font=2)
text(245, 450, 'Actual', cex=1.3, font=2)
rect(150, 305, 240, 365, col='#F7AD50')
rect(250, 305, 340, 365, col='#3F97D0')
text(140, 400, 'Non-essential', cex=1.2, srt=90)
text(140, 335, 'Essential', cex=1.2, srt=90)
# add in the cm results
res <- as.numeric(cm$table)
text(195, 400, res[1], cex=1.6, font=2, col='white')
text(195, 335, res[2], cex=1.6, font=2, col='white')
text(295, 400, res[3], cex=1.6, font=2, col='white')
text(295, 335, res[4], cex=1.6, font=2, col='white')
# add in the specifics
plot(c(100, 0), c(100, 0), type = "n", xlab="", ylab="", main = "DETAILS", xaxt='n', yaxt='n')
text(10, 85, names(cm$byClass[1]), cex=1.2, font=2)
text(10, 70, round(as.numeric(cm$byClass[1]), 3), cex=1.2)
text(30, 85, names(cm$byClass[2]), cex=1.2, font=2)
text(30, 70, round(as.numeric(cm$byClass[2]), 3), cex=1.2)
text(50, 85, names(cm$byClass[5]), cex=1.2, font=2)
text(50, 70, round(as.numeric(cm$byClass[5]), 3), cex=1.2)
text(70, 85, names(cm$byClass[6]), cex=1.2, font=2)
text(70, 70, round(as.numeric(cm$byClass[6]), 3), cex=1.2)
text(90, 85, names(cm$byClass[7]), cex=1.2, font=2)
text(90, 70, round(as.numeric(cm$byClass[7]), 3), cex=1.2)
# add in the accuracy information
text(30, 35, names(cm$overall[1]), cex=1.5, font=2)
text(30, 20, round(as.numeric(cm$overall[1]), 3), cex=1.4)
text(70, 35, names(cm$overall[2]), cex=1.5, font=2)
text(70, 20, round(as.numeric(cm$overall[2]), 3), cex=1.4)
}
draw_confusion_matrix(cm)
#write.csv(test1,'predicted_essential.csv')
homo_data = read.csv('network_measures.csv')
head(homo_data)
no_name = homo_data%>%clean_names() %>% select(-x_name)
head(homo_data)
head(no_name)
pred_homo <- predict(rf_impurity, no_name) # type='response' is the default - used for classification
pred_homo
homo_preds = pred_homo$predictions
homo_preds
homo_data_predicted = no_name
homo_data_predicted$ess_pred = homo_preds
head(homo_data_predicted)
no_name = homo_data%>%clean_names() %>% select(-x_name)%>%select(-essential)
pred_homo <- predict(rf_impurity, no_name) # type='response' is the default - used for classification
homo_preds = pred_homo$predictions
homo_data_predicted = no_name
homo_data_predicted$ess_pred = homo_preds
head(homo_data_predicted)
homo_data_predicted%>%filter(essential==1 )
homo_data_predicted%>%filter(ess_pred==1)
homo_data_predicted = homo_data
homo_data_predicted$ess_pred = homo_preds
essential_homo_data = homo_data_predicted%>%filter(ess_pred==1)%>%select
essential_homo_data = homo_data_predicted%>%filter(ess_pred==1)%>%select(x_name)
essential_homo_data = homo_data_predicted%>%filter(ess_pred==1)%>%select(X..Name)
essential_homo_data = homo_data_predicted%>%filter(ess_pred==1)%>%select(X..Name)%>%rename(protein=X..Name)
essential_homo_data
essential_homo_list = write.csv(essential_homo_data,'essential_homo_proteins.csv')
nrow(essential_homo_data)
